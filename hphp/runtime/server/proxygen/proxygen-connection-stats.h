/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2023-present Slack Technologies.                       |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/

#pragma once

#include "hphp/util/service-data.h"
#include "hphp/util/timer.h"

#include "proxygen/lib/http/session/HTTPTransaction.h"

namespace HPHP {

namespace {
const int kMinDurationMs = 0;
// Data points above kMaxDurationMs are unreliable due to how folly stores
// the histogram. This ends up overestimating the bucket above kMaxDurationMs,
// which impacts the tail end of our latency distribution (P90, P99).
// Thus it is better to use a high value for this counter.
// See https://github.com/facebook/folly/blob/main/folly/docs/Histogram.md#histogram
const int kMaxDurationMs = 5000;
const int kBucketSizeMs = 5;
}

// This class is inspirated by ::proxygen::ConnectionStats, but it uses
// HHVM's ServiceData instead of Fb303 to store its data.
class ProxygenConnectionStats final : public proxygen::HTTPTransactionTransportCallback {
public:
  ProxygenConnectionStats()
    : m_connectionDuration(ServiceData::createHistogram("proxygen_duration_ms", kBucketSizeMs, kMinDurationMs, kMaxDurationMs, {0.5, 0.90, 0.99}))
    , m_ingressBytes(ServiceData::createTimeSeries("proxygen_ingress_bytes", {ServiceData::StatsType::SUM}))
    , m_egressBytes(ServiceData::createTimeSeries("proxygen_egress_bytes", {ServiceData::StatsType::SUM})) {
  }

  // HTTPTransactionTransportCallback
  void firstHeaderByteFlushed() noexcept final { }
  void firstByteFlushed() noexcept final { }
  void lastByteAcked(std::chrono::milliseconds latency) noexcept final { }

  void lastByteFlushed() noexcept final {
    int64_t endUs = Timer::GetCurrentTimeMicros();
    int64_t durationMs = (endUs - m_requestStartUs) / 1000;
    VLOG(4) << "Recording latency: " << durationMs << " (start = " << m_requestStartUs << ", end = " << endUs << ")";
    m_connectionDuration->addValue(durationMs);
  }

  void headerBytesGenerated(proxygen::HTTPHeaderSize& size) noexcept final {
    VLOG(4) << "Counting headers generated bytes: " << size.uncompressed;
    addEgressBytes(size.uncompressed);
  }

  void bodyBytesGenerated(size_t nbytes) noexcept final {
    VLOG(4) << "Counting body generated bytes: " << nbytes;
    // This may slightly overcount as it may include extra bytes
    // for EOF/trailers, which seems reasonable.
    addEgressBytes(nbytes);
  }

  void headerBytesReceived(const proxygen::HTTPHeaderSize& size) noexcept final {
    VLOG(4) << "Counting headers received bytes: " << size.uncompressed;
    // We consider the end of the headers the start of the request, which
    // is not completely correct, but should be accurate enough in practice.
    //
    // I don't think this handles multiplexed protocols (like HTTP/2.0)
    // correctly, but ProxygenTransport assumes a single Transaction at a time
    // so I don't think it would either.
    m_requestStartUs = Timer::GetCurrentTimeMicros();
    addIngressBytes(size.uncompressed);
  }

  void bodyBytesReceived(size_t size) noexcept final {
    VLOG(4) << "Counting body received bytes: " << size;
    addIngressBytes(size);
  }

private:
  void addEgressBytes(size_t bytes) {
    m_egressBytes->addValue(bytes);
  }

  void addIngressBytes(size_t bytes) {
    m_ingressBytes->addValue(bytes);
  }

  ServiceData::ExportedHistogram* m_connectionDuration;
  ServiceData::ExportedTimeSeries* m_ingressBytes;
  ServiceData::ExportedTimeSeries* m_egressBytes;

  int64_t m_requestStartUs;
};

} // namespace HPHP
